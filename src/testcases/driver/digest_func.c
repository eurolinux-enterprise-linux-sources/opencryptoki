// File: digest.c
//

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <memory.h>

#include "pkcs11types.h"
#include "regress.h"

#include "md5.h"

struct hmac_test_vector
{
	/* test vector inputs */
	CK_BYTE  key[512];
	CK_ULONG key_len;
	CK_BYTE  data[512];
	CK_ULONG data_len;
	/* mechanism to test, with result len and result */
	CK_MECHANISM  mech;
	CK_ULONG      hash_len;
	CK_BYTE       result[512];
};

CK_ULONG four = 4;

#define NUM_HMAC_TEST_VECTORS	52

/* MD5 HMAC and SHA1 HMAC test vectors from RFC2202:
 * http://www.faqs.org/rfcs/rfc2202.html
 *
 * Test vectors for SHA256 and SHA512 from RFC4868:
 * http://tools.ietf.org/html/rfc4868
 */

struct hmac_test_vector hmac_test_vectors[NUM_HMAC_TEST_VECTORS] = {
	/* SHA1 HMAC tests */
	{ .key = { 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
		   0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b },
	  .key_len = 20,
	  .data = { "Hi There" },
	  .data_len = 8,
	  .mech = { CKM_SHA_1_HMAC, 0, 0 },
	  .hash_len = 20,
	  .result = { 0xb6, 0x17, 0x31, 0x86, 0x55, 0x05, 0x72, 0x64, 0xe2, 0x8b,
		      0xc0, 0xb6, 0xfb, 0x37, 0x8c, 0x8e, 0xf1, 0x46, 0xbe, 0x00 }
	},
	{ .key = { 'J', 'e', 'f', 'e' },
	  .key_len = 4,
	  .data = { "what do ya want for nothing?" },
	  .data_len = 28,
	  .mech = { CKM_SHA_1_HMAC, 0, 0 },
	  .hash_len = 20,
	  .result = { 0xef, 0xfc, 0xdf, 0x6a, 0xe5, 0xeb, 0x2f, 0xa2, 0xd2, 0x74,
		      0x16, 0xd5, 0xf1, 0x84, 0xdf, 0x9c, 0x25, 0x9a, 0x7c, 0x79 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 20,
	  .data = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD },
	  .data_len = 50,
	  .mech = { CKM_SHA_1_HMAC, 0, 0 },
	  .hash_len = 20,
	  .result = { 0x12, 0x5d, 0x73, 0x42, 0xb9, 0xac, 0x11, 0xcd, 0x91, 0xa3, 0x9a, 0xf4,
		      0x8a, 0xa1, 0x7b, 0x4f, 0x63, 0xf1, 0x75, 0xd3 }
	},
	{ .key = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
		   0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19 },
	  .key_len = 25,
	  .data = { 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD },
	  .data_len = 50,
	  .mech = { CKM_SHA_1_HMAC, 0, 0 },
	  .hash_len = 20,
	  .result = { 0x4c, 0x90, 0x07, 0xf4, 0x02, 0x62, 0x50, 0xc6, 0xbc, 0x84, 0x14, 0xf9,
		      0xbf, 0x50, 0xc8, 0x6c, 0x2d, 0x72, 0x35, 0xda }
	},
	{ .key = { 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
		   0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c },
	  .key_len = 20,
	  .data = { "Test With Truncation" },
	  .data_len = 20,
	  .mech = { CKM_SHA_1_HMAC, 0, 0 },
	  .hash_len = 20,
	  .result = { 0x4c, 0x1a, 0x03, 0x42, 0x4b, 0x55, 0xe0, 0x7f, 0xe7, 0xf2, 0x7b, 0xe1,
		      0xd5, 0x8b, 0xb9, 0x32, 0x4a, 0x9a, 0x5a, 0x04 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 80,
	  .data = { "Test Using Larger Than Block-Size Key - Hash Key First" },
	  .data_len = 54,
	  .mech = { CKM_SHA_1_HMAC, 0, 0 },
	  .hash_len = 20,
	  .result = { 0xaa, 0x4a, 0xe5, 0xe1, 0x52, 0x72, 0xd0, 0x0e, 0x95, 0x70, 0x56,
		      0x37, 0xce, 0x8a, 0x3b, 0x55, 0xed, 0x40, 0x21, 0x12 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 80,
	  .data = { "Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data" },
	  .data_len = 73,
	  .mech = { CKM_SHA_1_HMAC, 0, 0 },
	  .hash_len = 20,
	  .result = { 0xe8, 0xe9, 0x9d, 0x0f, 0x45, 0x23, 0x7d, 0x78, 0x6d, 0x6b,
		      0xba, 0xa7, 0x96, 0x5c, 0x78, 0x08, 0xbb, 0xff, 0x1a, 0x91 }
	},
	{ .key = { 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
		   0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b },
	  .key_len = 20,
	  .data = { "Hi There" },
	  .data_len = 8,
	  .mech = { CKM_SHA_1_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 20,
	  .result = { 0xb6, 0x17, 0x31, 0x86, 0x55, 0x05, 0x72, 0x64, 0xe2, 0x8b,
		      0xc0, 0xb6, 0xfb, 0x37, 0x8c, 0x8e, 0xf1, 0x46, 0xbe, 0x00 }
	},
	{ .key = { 'J', 'e', 'f', 'e' },
	  .key_len = 4,
	  .data = { "what do ya want for nothing?" },
	  .data_len = 28,
	  .mech = { CKM_SHA_1_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 20,
	  .result = { 0xef, 0xfc, 0xdf, 0x6a, 0xe5, 0xeb, 0x2f, 0xa2, 0xd2, 0x74,
		      0x16, 0xd5, 0xf1, 0x84, 0xdf, 0x9c, 0x25, 0x9a, 0x7c, 0x79 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 20,
	  .data = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD },
	  .data_len = 50,
	  .mech = { CKM_SHA_1_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 20,
	  .result = { 0x12, 0x5d, 0x73, 0x42, 0xb9, 0xac, 0x11, 0xcd, 0x91, 0xa3, 0x9a, 0xf4,
		      0x8a, 0xa1, 0x7b, 0x4f, 0x63, 0xf1, 0x75, 0xd3 }
	},
	{ .key = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
		   0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19 },
	  .key_len = 25,
	  .data = { 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD },
	  .data_len = 50,
	  .mech = { CKM_SHA_1_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 20,
	  .result = { 0x4c, 0x90, 0x07, 0xf4, 0x02, 0x62, 0x50, 0xc6, 0xbc, 0x84, 0x14, 0xf9,
		      0xbf, 0x50, 0xc8, 0x6c, 0x2d, 0x72, 0x35, 0xda }
	},
	{ .key = { 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
		   0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c },
	  .key_len = 20,
	  .data = { "Test With Truncation" },
	  .data_len = 20,
	  .mech = { CKM_SHA_1_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 20,
	  .result = { 0x4c, 0x1a, 0x03, 0x42, 0x4b, 0x55, 0xe0, 0x7f, 0xe7, 0xf2, 0x7b, 0xe1,
		      0xd5, 0x8b, 0xb9, 0x32, 0x4a, 0x9a, 0x5a, 0x04 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 80,
	  .data = { "Test Using Larger Than Block-Size Key - Hash Key First" },
	  .data_len = 54,
	  .mech = { CKM_SHA_1_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 20,
	  .result = { 0xaa, 0x4a, 0xe5, 0xe1, 0x52, 0x72, 0xd0, 0x0e, 0x95, 0x70, 0x56,
		      0x37, 0xce, 0x8a, 0x3b, 0x55, 0xed, 0x40, 0x21, 0x12 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 80,
	  .data = { "Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data" },
	  .data_len = 73,
	  .mech = { CKM_SHA_1_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 20,
	  .result = { 0xe8, 0xe9, 0x9d, 0x0f, 0x45, 0x23, 0x7d, 0x78, 0x6d, 0x6b,
		      0xba, 0xa7, 0x96, 0x5c, 0x78, 0x08, 0xbb, 0xff, 0x1a, 0x91 }
	},
	/* MD5 HMAC tests */
	{ .key = { 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb },
	  .key_len = 16,
	  .data = { "Hi There" },
	  .data_len = 8,
	  .mech = { CKM_MD5_HMAC, 0, 0 },
	  .hash_len = 16,
	  .result = { 0x92, 0x94, 0x72, 0x7a, 0x36, 0x38, 0xBB, 0x1C,
		      0x13, 0xf4, 0x8E, 0xf8, 0x15, 0x8b, 0xfc, 0x9d }
	},
	{ .key = { 'J', 'e', 'f', 'e' },
	  .key_len = 4,
	  .data = { "what do ya want for nothing?" },
	  .data_len = 28,
	  .mech = { CKM_MD5_HMAC, 0, 0 },
	  .hash_len = 16,
	  .result = { 0x75, 0x0c, 0x78, 0x3e, 0x6a, 0xb0, 0xb5, 0x03,
		      0xea, 0xa8, 0x6e, 0x31, 0x0a, 0x5d, 0xb7, 0x38 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 16,
	  .data = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD },
	  .data_len = 50,
	  .mech = { CKM_MD5_HMAC, 0, 0 },
	  .hash_len = 16,
	  .result = { 0x56, 0xbe, 0x34, 0x52, 0x1d, 0x14, 0x4c, 0x88,
		      0xdb, 0xb8, 0xc7, 0x33, 0xf0, 0xe8, 0xb3, 0xf6 }
	},
	{ .key = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
		   0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19 },
	  .key_len = 25,
	  .data = { 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD },
	  .data_len = 50,
	  .mech = { CKM_MD5_HMAC, 0, 0 },
	  .hash_len = 16,
	  .result = { 0x69, 0x7e, 0xaf, 0x0a, 0xca, 0x3a, 0x3a, 0xea,
		      0x3a, 0x75, 0x16, 0x47, 0x46, 0xff, 0xaa, 0x79 }
	},
	{ .key = { 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
		   0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c },
	  .key_len = 16,
	  .data = { "Test With Truncation" },
	  .data_len = 20,
	  .mech = { CKM_MD5_HMAC, 0, 0 },
	  .hash_len = 16,
	  .result = { 0x56, 0x46, 0x1e, 0xf2, 0x34, 0x2e, 0xdc, 0x00,
		      0xf9, 0xba, 0xb9, 0x95, 0x69, 0x0e, 0xfd, 0x4c}
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 80,
	  .data = { "Test Using Larger Than Block-Size Key - Hash Key First" },
	  .data_len = 54,
	  .mech = { CKM_MD5_HMAC, 0, 0 },
	  .hash_len = 16,
	  .result = { 0x6b, 0x1a, 0xb7, 0xfe, 0x4b, 0xd7, 0xbf, 0x8f,
		      0x0b, 0x62, 0xe6, 0xce, 0x61, 0xb9, 0xd0, 0xcd }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 80,
	  .data = { "Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data" },
	  .data_len = 73,
	  .mech = { CKM_MD5_HMAC, 0, 0 },
	  .hash_len = 16,
	  .result = { 0x6f, 0x63, 0x0f, 0xad, 0x67, 0xcd, 0xa0, 0xee,
		      0x1f, 0xb1, 0xf5, 0x62, 0xdb, 0x3a, 0xa5, 0x3e }
	},
	{ .key = { 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb },
	  .key_len = 16,
	  .data = { "Hi There" },
	  .data_len = 8,
	  .mech = { CKM_MD5_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 16,
	  .result = { 0x92, 0x94, 0x72, 0x7a, 0x36, 0x38, 0xBB, 0x1C,
		      0x13, 0xf4, 0x8E, 0xf8, 0x15, 0x8b, 0xfc, 0x9d }
	},
	{ .key = { 'J', 'e', 'f', 'e' },
	  .key_len = 4,
	  .data = { "what do ya want for nothing?" },
	  .data_len = 28,
	  .mech = { CKM_MD5_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 16,
	  .result = { 0x75, 0x0c, 0x78, 0x3e, 0x6a, 0xb0, 0xb5, 0x03,
		      0xea, 0xa8, 0x6e, 0x31, 0x0a, 0x5d, 0xb7, 0x38 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 16,
	  .data = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD },
	  .data_len = 50,
	  .mech = { CKM_MD5_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 16,
	  .result = { 0x56, 0xbe, 0x34, 0x52, 0x1d, 0x14, 0x4c, 0x88,
		      0xdb, 0xb8, 0xc7, 0x33, 0xf0, 0xe8, 0xb3, 0xf6 }
	},
	{ .key = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
		   0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19 },
	  .key_len = 25,
	  .data = { 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD },
	  .data_len = 50,
	  .mech = { CKM_MD5_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 16,
	  .result = { 0x69, 0x7e, 0xaf, 0x0a, 0xca, 0x3a, 0x3a, 0xea,
		      0x3a, 0x75, 0x16, 0x47, 0x46, 0xff, 0xaa, 0x79 }
	},
	{ .key = { 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
		   0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c },
	  .key_len = 16,
	  .data = { "Test With Truncation" },
	  .data_len = 20,
	  .mech = { CKM_MD5_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 16,
	  .result = { 0x56, 0x46, 0x1e, 0xf2, 0x34, 0x2e, 0xdc, 0x00,
		      0xf9, 0xba, 0xb9, 0x95, 0x69, 0x0e, 0xfd, 0x4c}
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 80,
	  .data = { "Test Using Larger Than Block-Size Key - Hash Key First" },
	  .data_len = 54,
	  .mech = { CKM_MD5_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 16,
	  .result = { 0x6b, 0x1a, 0xb7, 0xfe, 0x4b, 0xd7, 0xbf, 0x8f,
		      0x0b, 0x62, 0xe6, 0xce, 0x61, 0xb9, 0xd0, 0xcd }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 80,
	  .data = { "Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data" },
	  .data_len = 73,
	  .mech = { CKM_MD5_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 16,
	  .result = { 0x6f, 0x63, 0x0f, 0xad, 0x67, 0xcd, 0xa0, 0xee,
		      0x1f, 0xb1, 0xf5, 0x62, 0xdb, 0x3a, 0xa5, 0x3e }
	},
	/* SHA-256 HMAC tests */
	{ .key = { 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
		   0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b },
	  .key_len = 20,
	  .data = { "Hi There" },
	  .data_len = 8,
	  .mech = { CKM_SHA256_HMAC, 0, 0 },
	  .hash_len = 32,
	  .result = { 0xb0, 0x34, 0x4c, 0x61, 0xd8, 0xdb, 0x38, 0x53, 0x5c, 0xa8, 0xaf, 0xce, 0xaf,
		      0x0b, 0xf1, 0x2b, 0x88, 0x1d, 0xc2, 0x00, 0xc9, 0x83, 0x3d, 0xa7, 0x26, 0xe9,
		      0x37, 0x6c, 0x2e, 0x32, 0xcf, 0xf7 }
	},
	{ .key = { 'J', 'e', 'f', 'e' },
	  .key_len = 4,
	  .data = { "what do ya want for nothing?" },
	  .data_len = 28,
	  .mech = { CKM_SHA256_HMAC, 0, 0 },
	  .hash_len = 32,
	  .result = { 0x5b, 0xdc, 0xc1, 0x46, 0xbf, 0x60, 0x75, 0x4e, 0x6a, 0x04, 0x24, 0x26, 0x08,
		      0x95, 0x75, 0xc7, 0x5a, 0x00, 0x3f, 0x08, 0x9d, 0x27, 0x39, 0x83, 0x9d, 0xec,
		      0x58, 0xb9, 0x64, 0xec, 0x38, 0x43 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 20,
	  .data = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD },
	  .data_len = 50,
	  .mech = { CKM_SHA256_HMAC, 0, 0 },
	  .hash_len = 32,
	  .result = { 0x77, 0x3e, 0xa9, 0x1e, 0x36, 0x80, 0x0e, 0x46, 0x85, 0x4d, 0xb8, 0xeb, 0xd0,
		      0x91, 0x81, 0xa7, 0x29, 0x59, 0x09, 0x8b, 0x3e, 0xf8, 0xc1, 0x22, 0xd9, 0x63,
		      0x55, 0x14, 0xce, 0xd5, 0x65, 0xfe }
	},
	{ .key = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
		   0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19 },
	  .key_len = 25,
	  .data = { 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD },
	  .data_len = 50,
	  .mech = { CKM_SHA256_HMAC, 0, 0 },
	  .hash_len = 32,
	  .result = { 0x82, 0x55, 0x8a, 0x38, 0x9a, 0x44, 0x3c, 0x0e, 0xa4, 0xcc, 0x81, 0x98, 0x99,
		      0xf2, 0x08, 0x3a, 0x85, 0xf0, 0xfa, 0xa3, 0xe5, 0x78, 0xf8, 0x07, 0x7a, 0x2e,
		      0x3f, 0xf4, 0x67, 0x29, 0x66, 0x5b }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 131,
	  .data = { "Test Using Larger Than Block-Size Key - Hash Key First" },
	  .data_len = 54,
	  .mech = { CKM_SHA256_HMAC, 0, 0 },
	  .hash_len = 32,
	  .result = { 0x60, 0xe4, 0x31, 0x59, 0x1e, 0xe0, 0xb6, 0x7f, 0x0d, 0x8a, 0x26, 0xaa, 0xcb,
		      0xf5, 0xb7, 0x7f, 0x8e, 0x0b, 0xc6, 0x21, 0x37, 0x28, 0xc5, 0x14, 0x05, 0x46,
		      0x04, 0x0f, 0x0e, 0xe3, 0x7f, 0x54 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 131,
	  .data = { "This is a test using a larger than block-size key and a larger than block-size"
		    " data. The key needs to be hashed before being used by the HMAC algorithm." },
	  .data_len = 148,
	  .mech = { CKM_SHA256_HMAC, 0, 0 },
	  .hash_len = 32,
	  .result = { 0x9b, 0x09, 0xff, 0xa7, 0x1b, 0x94, 0x2f, 0xcb, 0x27, 0x63, 0x5f, 0xbc, 0xd5,
		      0xb0, 0xe9, 0x44, 0xbf, 0xdc, 0x63, 0x64, 0x4f, 0x07, 0x13, 0x93, 0x8a, 0x7f,
		      0x51, 0x53, 0x5c, 0x3a, 0x35, 0xe2 }
	},
	{ .key = { 'J', 'e', 'f', 'e' },
	  .key_len = 4,
	  .data = { "what do ya want for nothing?" },
	  .data_len = 28,
	  .mech = { CKM_SHA256_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 32,
	  .result = { 0x5b, 0xdc, 0xc1, 0x46, 0xbf, 0x60, 0x75, 0x4e, 0x6a, 0x04, 0x24, 0x26, 0x08,
		      0x95, 0x75, 0xc7, 0x5a, 0x00, 0x3f, 0x08, 0x9d, 0x27, 0x39, 0x83, 0x9d, 0xec,
		      0x58, 0xb9, 0x64, 0xec, 0x38, 0x43 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 20,
	  .data = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD },
	  .data_len = 50,
	  .mech = { CKM_SHA256_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 32,
	  .result = { 0x77, 0x3e, 0xa9, 0x1e, 0x36, 0x80, 0x0e, 0x46, 0x85, 0x4d, 0xb8, 0xeb, 0xd0,
		      0x91, 0x81, 0xa7, 0x29, 0x59, 0x09, 0x8b, 0x3e, 0xf8, 0xc1, 0x22, 0xd9, 0x63,
		      0x55, 0x14, 0xce, 0xd5, 0x65, 0xfe }
	},
	{ .key = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
		   0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19 },
	  .key_len = 25,
	  .data = { 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD },
	  .data_len = 50,
	  .mech = { CKM_SHA256_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 32,
	  .result = { 0x82, 0x55, 0x8a, 0x38, 0x9a, 0x44, 0x3c, 0x0e, 0xa4, 0xcc, 0x81, 0x98, 0x99,
		      0xf2, 0x08, 0x3a, 0x85, 0xf0, 0xfa, 0xa3, 0xe5, 0x78, 0xf8, 0x07, 0x7a, 0x2e,
		      0x3f, 0xf4, 0x67, 0x29, 0x66, 0x5b }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 131,
	  .data = { "Test Using Larger Than Block-Size Key - Hash Key First" },
	  .data_len = 54,
	  .mech = { CKM_SHA256_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 32,
	  .result = { 0x60, 0xe4, 0x31, 0x59, 0x1e, 0xe0, 0xb6, 0x7f, 0x0d, 0x8a, 0x26, 0xaa, 0xcb,
		      0xf5, 0xb7, 0x7f, 0x8e, 0x0b, 0xc6, 0x21, 0x37, 0x28, 0xc5, 0x14, 0x05, 0x46,
		      0x04, 0x0f, 0x0e, 0xe3, 0x7f, 0x54 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 131,
	  .data = { "This is a test using a larger than block-size key and a larger than block-size"
		    " data. The key needs to be hashed before being used by the HMAC algorithm." },
	  .data_len = 148,
	  .mech = { CKM_SHA256_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 32,
	  .result = { 0x9b, 0x09, 0xff, 0xa7, 0x1b, 0x94, 0x2f, 0xcb, 0x27, 0x63, 0x5f, 0xbc, 0xd5,
		      0xb0, 0xe9, 0x44, 0xbf, 0xdc, 0x63, 0x64, 0x4f, 0x07, 0x13, 0x93, 0x8a, 0x7f,
		      0x51, 0x53, 0x5c, 0x3a, 0x35, 0xe2 }
	},
	/* SHA-512 HMAC tests */
	{ .key = { 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
		   0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b },
	  .key_len = 20,
	  .data = { "Hi There" },
	  .data_len = 8,
	  .mech = { CKM_SHA512_HMAC, 0, 0 },
	  .hash_len = 64,
	  .result = { 0x87, 0xaa, 0x7c, 0xde, 0xa5, 0xef, 0x61, 0x9d, 0x4f, 0xf0, 0xb4, 0x24, 0x1a,
		      0x1d, 0x6c, 0xb0, 0x23, 0x79, 0xf4, 0xe2, 0xce, 0x4e, 0xc2, 0x78, 0x7a, 0xd0,
		      0xb3, 0x05, 0x45, 0xe1, 0x7c, 0xde, 0xda, 0xa8, 0x33, 0xb7, 0xd6, 0xb8, 0xa7,
		      0x02, 0x03, 0x8b, 0x27, 0x4e, 0xae, 0xa3, 0xf4, 0xe4, 0xbe, 0x9d, 0x91, 0x4e,
		      0xeb, 0x61, 0xf1, 0x70, 0x2e, 0x69, 0x6c, 0x20, 0x3a, 0x12, 0x68, 0x54 }
	},
	{ .key = { 'J', 'e', 'f', 'e' },
	  .key_len = 4,
	  .data = { "what do ya want for nothing?" },
	  .data_len = 28,
	  .mech = { CKM_SHA512_HMAC, 0, 0 },
	  .hash_len = 64,
	  .result = { 0x16, 0x4b, 0x7a, 0x7b, 0xfc, 0xf8, 0x19, 0xe2, 0xe3, 0x95, 0xfb, 0xe7, 0x3b,
		      0x56, 0xe0, 0xa3, 0x87, 0xbd, 0x64, 0x22, 0x2e, 0x83, 0x1f, 0xd6, 0x10, 0x27,
		      0x0c, 0xd7, 0xea, 0x25, 0x05, 0x54, 0x97, 0x58, 0xbf, 0x75, 0xc0, 0x5a, 0x99,
		      0x4a, 0x6d, 0x03, 0x4f, 0x65, 0xf8, 0xf0, 0xe6, 0xfd, 0xca, 0xea, 0xb1, 0xa3,
		      0x4d, 0x4a, 0x6b, 0x4b, 0x63, 0x6e, 0x07, 0x0a, 0x38, 0xbc, 0xe7, 0x37 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 20,
	  .data = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD },
	  .data_len = 50,
	  .mech = { CKM_SHA512_HMAC, 0, 0 },
	  .hash_len = 64,
	  .result = { 0xfa, 0x73, 0xb0, 0x08, 0x9d, 0x56, 0xa2, 0x84, 0xef, 0xb0, 0xf0, 0x75, 0x6c,
		      0x89, 0x0b, 0xe9, 0xb1, 0xb5, 0xdb, 0xdd, 0x8e, 0xe8, 0x1a, 0x36, 0x55, 0xf8,
		      0x3e, 0x33, 0xb2, 0x27, 0x9d, 0x39, 0xbf, 0x3e, 0x84, 0x82, 0x79, 0xa7, 0x22,
		      0xc8, 0x06, 0xb4, 0x85, 0xa4, 0x7e, 0x67, 0xc8, 0x07, 0xb9, 0x46, 0xa3, 0x37,
		      0xbe, 0xe8, 0x94, 0x26, 0x74, 0x27, 0x88, 0x59, 0xe1, 0x32, 0x92, 0xfb }
	},
	{ .key = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
		   0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19 },
	  .key_len = 25,
	  .data = { 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD },
	  .data_len = 50,
	  .mech = { CKM_SHA512_HMAC, 0, 0 },
	  .hash_len = 64,
	  .result = { 0xb0, 0xba, 0x46, 0x56, 0x37, 0x45, 0x8c, 0x69, 0x90, 0xe5, 0xa8, 0xc5, 0xf6,
		      0x1d, 0x4a, 0xf7, 0xe5, 0x76, 0xd9, 0x7f, 0xf9, 0x4b, 0x87, 0x2d, 0xe7, 0x6f,
		      0x80, 0x50, 0x36, 0x1e, 0xe3, 0xdb, 0xa9, 0x1c, 0xa5, 0xc1, 0x1a, 0xa2, 0x5e,
		      0xb4, 0xd6, 0x79, 0x27, 0x5c, 0xc5, 0x78, 0x80, 0x63, 0xa5, 0xf1, 0x97, 0x41,
		      0x12, 0x0c, 0x4f, 0x2d, 0xe2, 0xad, 0xeb, 0xeb, 0x10, 0xa2, 0x98, 0xdd }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 131,
	  .data = { "Test Using Larger Than Block-Size Key - Hash Key First" },
	  .data_len = 54,
	  .mech = { CKM_SHA512_HMAC, 0, 0 },
	  .hash_len = 64,
	  .result = { 0x80, 0xb2, 0x42, 0x63, 0xc7, 0xc1, 0xa3, 0xeb, 0xb7, 0x14, 0x93, 0xc1, 0xdd,
		      0x7b, 0xe8, 0xb4, 0x9b, 0x46, 0xd1, 0xf4, 0x1b, 0x4a, 0xee, 0xc1, 0x12, 0x1b,
		      0x01, 0x37, 0x83, 0xf8, 0xf3, 0x52, 0x6b, 0x56, 0xd0, 0x37, 0xe0, 0x5f, 0x25,
		      0x98, 0xbd, 0x0f, 0xd2, 0x21, 0x5d, 0x6a, 0x1e, 0x52, 0x95, 0xe6, 0x4f, 0x73,
		      0xf6, 0x3f, 0x0a, 0xec, 0x8b, 0x91, 0x5a, 0x98, 0x5d, 0x78, 0x65, 0x98 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 131,
	  .data = { "This is a test using a larger than block-size key and a larger than block-size"
		    " data. The key needs to be hashed before being used by the HMAC algorithm." },
	  .data_len = 148,
	  .mech = { CKM_SHA512_HMAC, 0, 0 },
	  .hash_len = 64,
	  .result = { 0xe3, 0x7b, 0x6a, 0x77, 0x5d, 0xc8, 0x7d, 0xba, 0xa4, 0xdf, 0xa9, 0xf9, 0x6e,
		      0x5e, 0x3f, 0xfd, 0xde, 0xbd, 0x71, 0xf8, 0x86, 0x72, 0x89, 0x86, 0x5d, 0xf5,
		      0xa3, 0x2d, 0x20, 0xcd, 0xc9, 0x44, 0xb6, 0x02, 0x2c, 0xac, 0x3c, 0x49, 0x82,
		      0xb1, 0x0d, 0x5e, 0xeb, 0x55, 0xc3, 0xe4, 0xde, 0x15, 0x13, 0x46, 0x76, 0xfb,
		      0x6d, 0xe0, 0x44, 0x60, 0x65, 0xc9, 0x74, 0x40, 0xfa, 0x8c, 0x6a, 0x58 }
	},
	{ .key = { 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
		   0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b },
	  .key_len = 20,
	  .data = { "Hi There" },
	  .data_len = 8,
	  .mech = { CKM_SHA512_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 64,
	  .result = { 0x87, 0xaa, 0x7c, 0xde, 0xa5, 0xef, 0x61, 0x9d, 0x4f, 0xf0, 0xb4, 0x24, 0x1a,
		      0x1d, 0x6c, 0xb0, 0x23, 0x79, 0xf4, 0xe2, 0xce, 0x4e, 0xc2, 0x78, 0x7a, 0xd0,
		      0xb3, 0x05, 0x45, 0xe1, 0x7c, 0xde, 0xda, 0xa8, 0x33, 0xb7, 0xd6, 0xb8, 0xa7,
		      0x02, 0x03, 0x8b, 0x27, 0x4e, 0xae, 0xa3, 0xf4, 0xe4, 0xbe, 0x9d, 0x91, 0x4e,
		      0xeb, 0x61, 0xf1, 0x70, 0x2e, 0x69, 0x6c, 0x20, 0x3a, 0x12, 0x68, 0x54 }
	},
	{ .key = { 'J', 'e', 'f', 'e' },
	  .key_len = 4,
	  .data = { "what do ya want for nothing?" },
	  .data_len = 28,
	  .mech = { CKM_SHA512_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 64,
	  .result = { 0x16, 0x4b, 0x7a, 0x7b, 0xfc, 0xf8, 0x19, 0xe2, 0xe3, 0x95, 0xfb, 0xe7, 0x3b,
		      0x56, 0xe0, 0xa3, 0x87, 0xbd, 0x64, 0x22, 0x2e, 0x83, 0x1f, 0xd6, 0x10, 0x27,
		      0x0c, 0xd7, 0xea, 0x25, 0x05, 0x54, 0x97, 0x58, 0xbf, 0x75, 0xc0, 0x5a, 0x99,
		      0x4a, 0x6d, 0x03, 0x4f, 0x65, 0xf8, 0xf0, 0xe6, 0xfd, 0xca, 0xea, 0xb1, 0xa3,
		      0x4d, 0x4a, 0x6b, 0x4b, 0x63, 0x6e, 0x07, 0x0a, 0x38, 0xbc, 0xe7, 0x37 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 20,
	  .data = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
		    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD },
	  .data_len = 50,
	  .mech = { CKM_SHA512_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 64,
	  .result = { 0xfa, 0x73, 0xb0, 0x08, 0x9d, 0x56, 0xa2, 0x84, 0xef, 0xb0, 0xf0, 0x75, 0x6c,
		      0x89, 0x0b, 0xe9, 0xb1, 0xb5, 0xdb, 0xdd, 0x8e, 0xe8, 0x1a, 0x36, 0x55, 0xf8,
		      0x3e, 0x33, 0xb2, 0x27, 0x9d, 0x39, 0xbf, 0x3e, 0x84, 0x82, 0x79, 0xa7, 0x22,
		      0xc8, 0x06, 0xb4, 0x85, 0xa4, 0x7e, 0x67, 0xc8, 0x07, 0xb9, 0x46, 0xa3, 0x37,
		      0xbe, 0xe8, 0x94, 0x26, 0x74, 0x27, 0x88, 0x59, 0xe1, 0x32, 0x92, 0xfb }
	},
	{ .key = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
		   0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19 },
	  .key_len = 25,
	  .data = { 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		    0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD },
	  .data_len = 50,
	  .mech = { CKM_SHA512_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 64,
	  .result = { 0xb0, 0xba, 0x46, 0x56, 0x37, 0x45, 0x8c, 0x69, 0x90, 0xe5, 0xa8, 0xc5, 0xf6,
		      0x1d, 0x4a, 0xf7, 0xe5, 0x76, 0xd9, 0x7f, 0xf9, 0x4b, 0x87, 0x2d, 0xe7, 0x6f,
		      0x80, 0x50, 0x36, 0x1e, 0xe3, 0xdb, 0xa9, 0x1c, 0xa5, 0xc1, 0x1a, 0xa2, 0x5e,
		      0xb4, 0xd6, 0x79, 0x27, 0x5c, 0xc5, 0x78, 0x80, 0x63, 0xa5, 0xf1, 0x97, 0x41,
		      0x12, 0x0c, 0x4f, 0x2d, 0xe2, 0xad, 0xeb, 0xeb, 0x10, 0xa2, 0x98, 0xdd }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 131,
	  .data = { "Test Using Larger Than Block-Size Key - Hash Key First" },
	  .data_len = 54,
	  .mech = { CKM_SHA512_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 64,
	  .result = { 0x80, 0xb2, 0x42, 0x63, 0xc7, 0xc1, 0xa3, 0xeb, 0xb7, 0x14, 0x93, 0xc1, 0xdd,
		      0x7b, 0xe8, 0xb4, 0x9b, 0x46, 0xd1, 0xf4, 0x1b, 0x4a, 0xee, 0xc1, 0x12, 0x1b,
		      0x01, 0x37, 0x83, 0xf8, 0xf3, 0x52, 0x6b, 0x56, 0xd0, 0x37, 0xe0, 0x5f, 0x25,
		      0x98, 0xbd, 0x0f, 0xd2, 0x21, 0x5d, 0x6a, 0x1e, 0x52, 0x95, 0xe6, 0x4f, 0x73,
		      0xf6, 0x3f, 0x0a, 0xec, 0x8b, 0x91, 0x5a, 0x98, 0x5d, 0x78, 0x65, 0x98 }
	},
	{ .key = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa },
	  .key_len = 131,
	  .data = { "This is a test using a larger than block-size key and a larger than block-size"
		    " data. The key needs to be hashed before being used by the HMAC algorithm." },
	  .data_len = 148,
	  .mech = { CKM_SHA512_HMAC_GENERAL, &four, sizeof(CK_ULONG) },
	  .hash_len = 64,
	  .result = { 0xe3, 0x7b, 0x6a, 0x77, 0x5d, 0xc8, 0x7d, 0xba, 0xa4, 0xdf, 0xa9, 0xf9, 0x6e,
		      0x5e, 0x3f, 0xfd, 0xde, 0xbd, 0x71, 0xf8, 0x86, 0x72, 0x89, 0x86, 0x5d, 0xf5,
		      0xa3, 0x2d, 0x20, 0xcd, 0xc9, 0x44, 0xb6, 0x02, 0x2c, 0xac, 0x3c, 0x49, 0x82,
		      0xb1, 0x0d, 0x5e, 0xeb, 0x55, 0xc3, 0xe4, 0xde, 0x15, 0x13, 0x46, 0x76, 0xfb,
		      0x6d, 0xe0, 0x44, 0x60, 0x65, 0xc9, 0x74, 0x40, 0xfa, 0x8c, 0x6a, 0x58 }
	}
};

//
//
CK_RV do_Digest_SHA1( void )
{
	CK_SESSION_HANDLE session;
	CK_SLOT_ID        slot_id;
	CK_MECHANISM      mech;
	CK_ULONG          flags;
	CK_ULONG          i;
	CK_RV             rc;


	printf("do_Digest_SHA1...\n");

	slot_id = SLOT_ID;
	flags = CKF_SERIAL_SESSION | CKF_RW_SESSION;
	rc = funcs->C_OpenSession( slot_id, flags, NULL, NULL, &session );
	if (rc != CKR_OK) {
		show_error("   C_OpenSession #1", rc );
		return rc;
	}

	// perform the hash tests from the FIPS 180-1 document
	//
	{
		CK_BYTE  data1[] = "abc";
		CK_BYTE  data2[] = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq";
		CK_ULONG data_len;
		CK_BYTE  expected1[] = {0xA9, 0x99, 0x3E, 0x36, 0x47, 0x06, 0x81, 0x6A, 0xBA, 0x3E, 0x25, 0x71, 0x78, 0x50, 0xC2, 0x6C, 0x9C, 0xD0, 0xD8, 0x9D };
		CK_BYTE  expected2[] = {0x84, 0x98, 0x3E, 0x44, 0x1C, 0x3B, 0xD2, 0x6E, 0xBA, 0xAE, 0x4A, 0xA1, 0xF9, 0x51, 0x29, 0xE5, 0xE5, 0x46, 0x70, 0xF1 };
		CK_BYTE  hash[20];
		CK_ULONG hash_len;

		mech.mechanism      = CKM_SHA_1;
		mech.ulParameterLen = 0;
		mech.pParameter     = NULL;

		//
		//
		rc = funcs->C_DigestInit( session, &mech );
		if (rc != CKR_OK) {
			show_error("   C_DigestInit #1", rc );
			return rc;
		}

		hash_len = sizeof(hash);
		data_len = strlen((char *)data1);
		rc = funcs->C_Digest( session, data1,    data_len,
				hash,    &hash_len );
		if (rc != CKR_OK) {
			show_error("   C_Digest #1", rc );
			return rc;
		}

		if (hash_len != 20) {
			PRINT_ERR("   ERROR #1:  hash_len == %ld, expected 20\n", hash_len );
			return -1;
		}

		if (memcmp(hash, expected1, hash_len) != 0) {
			PRINT_ERR("   ERROR #2:  hash output mismatch\n" );
			return -1;
		}


		//
		//
		rc = funcs->C_DigestInit( session, &mech );
		if (rc != CKR_OK) {
			show_error("   C_DigestInit #2", rc );
			return rc;
		}

		data_len = strlen((char *)data1);
		rc = funcs->C_DigestUpdate( session, data1, data_len );
		if (rc != CKR_OK) {
			show_error("   C_DigestUpdate #1", rc );
			return rc;
		}

		hash_len = sizeof(hash);
		rc = funcs->C_DigestFinal( session, hash, &hash_len );
		if (rc != CKR_OK) {
			show_error("   C_DigestFinal #1", rc );
			return rc;
		}

		if (hash_len != 20) {
			PRINT_ERR("   ERROR #3:  hash_len == %ld, expected 20\n", hash_len );
			return -1;
		}

		if (memcmp(hash, expected1, hash_len) != 0) {
			PRINT_ERR("   ERROR #4:  hash output mismatch\n" );
			return -1;
		}


		//
		//
		rc = funcs->C_DigestInit( session, &mech );
		if (rc != CKR_OK) {
			show_error("   C_DigestInit #3", rc );
			return rc;
		}

		hash_len = sizeof(hash);
		data_len = strlen((char *)data2);
		rc = funcs->C_Digest( session, data2,    data_len,
				hash,    &hash_len );
		if (rc != CKR_OK) {
			show_error("   C_Digest #2", rc );
			return rc;
		}

		if (hash_len != 20) {
			PRINT_ERR("   ERROR #5:  hash_len == %ld, expected 20\n", hash_len );
			return -1;
		}

		if (memcmp(hash, expected2, hash_len) != 0) {
			PRINT_ERR("   ERROR #6:  hash output mismatch\n" );
			return -1;
		}


		//
		//
		rc = funcs->C_DigestInit( session, &mech );
		if (rc != CKR_OK) {
			show_error("   C_DigestInit #4", rc );
			return rc;
		}

		data_len = strlen((char *)data2);
		rc = funcs->C_DigestUpdate( session, data2, data_len );
		if (rc != CKR_OK) {
			show_error("   C_DigestUpdate #2", rc );
			return rc;
		}

		hash_len = sizeof(hash);
		rc = funcs->C_DigestFinal( session, hash, &hash_len );
		if (rc != CKR_OK) {
			show_error("   C_DigestFinal #2", rc );
			return rc;
		}

		if (hash_len != 20) {
			PRINT_ERR("   ERROR #7:  hash_len == %ld, expected 20\n", hash_len );
			return -1;
		}

		if (memcmp(hash, expected2, hash_len) != 0) {
			PRINT_ERR("   ERROR #8:  hash output mismatch\n" );
			return -1;
		}
	}

	// now, do custom testing
	//
	{
		CK_BYTE           data[BIG_REQUEST];
		CK_BYTE           hash1[SHA1_HASH_LEN];
		CK_BYTE           hash2[SHA1_HASH_LEN];
		CK_BYTE           hash3[SHA1_HASH_LEN];
		CK_ULONG          data_len;
		CK_ULONG          hash_len;

		mech.mechanism      = CKM_SHA_1;
		mech.ulParameterLen = 0;
		mech.pParameter     = NULL;

		// generate some data to hash
		//
		data_len = sizeof(data);
		for (i=0; i < data_len; i++)
			data[i] = i % 255;


		// first, hash it all in 1 big block
		//
		rc = funcs->C_DigestInit( session, &mech );
		if (rc != CKR_OK) {
			show_error("   C_DigestInit #5", rc );
			return rc;
		}

		hash_len = sizeof(hash1);
		rc = funcs->C_Digest( session, data,     data_len,
				hash1,   &hash_len );
		if (rc != CKR_OK) {
			show_error("   C_Digest #3", rc );
			return rc;
		}

		if (hash_len != SHA1_HASH_LEN) {
			PRINT_ERR("   ERROR #9:  expected len1 to be %d.  Got %ld instead\n\n", SHA1_HASH_LEN, hash_len );
			return -1;
		}


		// now, hash it in 64-byte chunks.  this is an even multiple of the SHA1
		// blocksize
		//
		rc = funcs->C_DigestInit( session, &mech );
		if (rc != CKR_OK) {
			show_error("   C_DigestInit #6", rc );
			return rc;
		}

		for (i=0; i < sizeof(data); i += 64) {
			CK_ULONG size = sizeof(data) - i;
			size = MIN(size, 64);

			rc = funcs->C_DigestUpdate( session, &data[i], size );
			if (rc != CKR_OK) {
				show_error("   C_DigestUpdate #3", rc );
				PRINT_ERR("   Offset:  %ld\n", i);
				return rc;
			}
		}

		hash_len = sizeof(hash2);
		rc = funcs->C_DigestFinal( session, hash2, &hash_len );
		if (rc != CKR_OK) {
			show_error("   C_DigestFinal #3", rc );
			return rc;
		}

		if (hash_len != SHA1_HASH_LEN) {
			PRINT_ERR("   ERROR #10:  expected len2 to be %d.  Got %ld instead\n\n", SHA1_HASH_LEN, hash_len );
			return -1;
		}


		rc = funcs->C_DigestInit( session, &mech );
		if (rc != CKR_OK) {
			show_error("   C_DigestInit #3", rc );
			return rc;
		}


		// finally, hash it in 47-byte chunks.  this is not a multiple of the SHA1
		// block size.  it should exercise our ability to buffer requests
		// for the internal SHA1 restrictions
		//
		for (i=0; i < sizeof(data); i += 47) {
			CK_ULONG size = sizeof(data) - i;
			size = MIN(size, 47);

			rc = funcs->C_DigestUpdate( session, &data[i], size );
			if (rc != CKR_OK) {
				show_error("   C_DigestUpdate #4", rc );
				PRINT_ERR("   Offset:  %ld\n", i);
				return rc;
			}
		}

		hash_len = sizeof(hash3);
		rc = funcs->C_DigestFinal( session, hash3, &hash_len );
		if (rc != CKR_OK) {
			show_error("   C_DigestFinal #4", rc );
			return rc;
		}

		if (hash_len != SHA1_HASH_LEN) {
			PRINT_ERR("   ERROR #11:  expected len3 to be %d.  Got %ld instead\n\n", SHA1_HASH_LEN, hash_len );
			return -1;
		}


		// the hashes better be the same
		//
		if (memcmp(hash1, hash2, sizeof(hash1)) != 0) {
			PRINT_ERR("   ERROR #12:  hashes 1 and 2 don't match\n");
			return -1;
		}

		if (memcmp(hash1, hash3, sizeof(hash1)) != 0) {
			PRINT_ERR("   ERROR #13:  hashes 1 and 3 don't match\n");
			return -1;
		}
	}


	rc = funcs->C_CloseAllSessions( slot_id );
	if (rc != CKR_OK) {
		show_error("   C_CloseAllSessions #1", rc );
		return rc;
	}

	printf("Looks okay...\n");
	return 0;
}


//
//
CK_RV do_Digest_MD2( void )
{
	CK_SESSION_HANDLE session;
	CK_SLOT_ID        slot_id;
	CK_MECHANISM      mech;
	CK_BYTE           data[BIG_REQUEST];
	CK_BYTE           hash1[MD2_HASH_LEN];
	CK_BYTE           hash2[MD2_HASH_LEN];
	CK_BYTE           hash3[MD2_HASH_LEN];
	CK_ULONG          flags;
	CK_ULONG          data_len;
	CK_ULONG          hash_len;
	CK_ULONG          i;
	CK_RV             rc;


	printf("do_Digest_MD2...\n");

	slot_id = SLOT_ID;
	flags = CKF_SERIAL_SESSION | CKF_RW_SESSION;
	rc = funcs->C_OpenSession( slot_id, flags, NULL, NULL, &session );
	if (rc != CKR_OK) {
		show_error("   C_OpenSession #1", rc );
		return rc;
	}

	mech.mechanism      = CKM_MD2;
	mech.ulParameterLen = 0;
	mech.pParameter     = NULL;

	// generate some data to hash
	//
	data_len = sizeof(data);
	for (i=0; i < data_len; i++)
		data[i] = i % 255;


	// first, hash it all in 1 big block
	//
	rc = funcs->C_DigestInit( session, &mech );
	if (rc != CKR_OK) {
		show_error("   C_DigestInit #1", rc );
		return rc;
	}

	hash_len = sizeof(hash1);
	rc = funcs->C_Digest( session, data,     data_len,
			hash1,   &hash_len );
	if (rc != CKR_OK) {
		show_error("   C_Digest #1", rc );
		return rc;
	}

	if (hash_len != MD2_HASH_LEN) {
		PRINT_ERR("   ERROR:  expected len1 to be %d.  Got %ld instead\n\n", MD2_HASH_LEN, hash_len );
		return -1;
	}


	// now hash in 64-byte chunks
	//
	rc = funcs->C_DigestInit( session, &mech );
	if (rc != CKR_OK) {
		show_error("   C_DigestInit #2", rc );
		return rc;
	}

	for (i=0; i < sizeof(data); i += 64) {
		CK_ULONG size = sizeof(data) - i;
		size = MIN(size, 64);

		rc = funcs->C_DigestUpdate( session, &data[i], size );
		if (rc != CKR_OK) {
			show_error("   C_DigestUpdate #1", rc );
			PRINT_ERR("   Offset:  %ld\n", i);
			return rc;
		}
	}

	hash_len = sizeof(hash2);
	rc = funcs->C_DigestFinal( session, hash2, &hash_len );
	if (rc != CKR_OK) {
		show_error("   C_DigestFinal #1", rc );
		return rc;
	}

	if (hash_len != MD2_HASH_LEN) {
		PRINT_ERR("   ERROR:  expected len2 to be %d.  Got %ld instead\n\n", MD2_HASH_LEN, hash_len );
		return -1;
	}


	rc = funcs->C_DigestInit( session, &mech );
	if (rc != CKR_OK) {
		show_error("   C_DigestInit #3", rc );
		return rc;
	}


	// finally, hash it in 47-byte chunks.
	//
	for (i=0; i < sizeof(data); i += 47) {
		CK_ULONG size = sizeof(data) - i;
		size = MIN(size, 47);

		rc = funcs->C_DigestUpdate( session, &data[i], size );
		if (rc != CKR_OK) {
			show_error("   C_DigestUpdate #2", rc );
			PRINT_ERR("   Offset:  %ld\n", i);
			return rc;
		}
	}

	hash_len = sizeof(hash3);
	rc = funcs->C_DigestFinal( session, hash3, &hash_len );
	if (rc != CKR_OK) {
		show_error("   C_DigestFinal #2", rc );
		return rc;
	}

	if (hash_len != MD2_HASH_LEN) {
		PRINT_ERR("   ERROR:  expected len3 to be %d.  Got %ld instead\n\n", MD2_HASH_LEN, hash_len );
		return -1;
	}


	// the hashes better be the same
	//
	if (memcmp(hash1, hash2, sizeof(hash1)) != 0) {
		PRINT_ERR("   ERROR:  hashes 1 and 2 don't match\n");
		return -1;
	}

	if (memcmp(hash1, hash3, sizeof(hash1)) != 0) {
		PRINT_ERR("   ERROR:  hashes 1 and 3 don't match\n");
		return -1;
	}


	rc = funcs->C_CloseAllSessions( slot_id );
	if (rc != CKR_OK) {
		show_error("   C_CloseAllSessions #1", rc );
		return rc;
	}

	printf("Looks okay...\n");
	return 0;
}



//
//
CK_RV do_Digest_MD5( void )
{
	CK_SESSION_HANDLE session;
	CK_SLOT_ID        slot_id;
	CK_MECHANISM      mech;
	CK_BYTE           data[BIG_REQUEST];
	CK_BYTE           hash1[MD5_HASH_LEN];
	CK_BYTE           hash2[MD5_HASH_LEN];
	CK_BYTE           hash3[MD5_HASH_LEN];
	CK_ULONG          flags;
	CK_ULONG          data_len;
	CK_ULONG          hash_len;
	CK_ULONG          i;
	CK_RV             rc;


	// SAB new
	MD5_CTX   mdContext;


	printf("do_Digest_MD5...\n");

	slot_id = SLOT_ID;
	flags = CKF_SERIAL_SESSION | CKF_RW_SESSION;
	rc = funcs->C_OpenSession( slot_id, flags, NULL, NULL, &session );
	if (rc != CKR_OK) {
		show_error("   C_OpenSession #1", rc );
		return rc;
	}

	mech.mechanism      = CKM_MD5;
	mech.ulParameterLen = 0;
	mech.pParameter     = NULL;

	// generate some data to hash
	//
	data_len = sizeof(data);
	for (i=0; i < data_len; i++)
		data[i] = i % 255;


	// first, hash it all in 1 big block
	//
	rc = funcs->C_DigestInit( session, &mech );
	if (rc != CKR_OK) {
		show_error("   C_DigestInit #1", rc );
		return rc;
	}

	hash_len = sizeof(hash1);
	rc = funcs->C_Digest( session, data,     data_len,
			hash1,   &hash_len );
	if (rc != CKR_OK) {
		show_error("   C_Digest #1", rc );
		return rc;
	}

	if (hash_len != MD5_HASH_LEN) {
		PRINT_ERR("   ERROR:  expected len1 to be %d.  Got %ld instead\n\n", MD5_HASH_LEN, hash_len );
		return -1;
	}

	// SAB Verify...
	MD5Init(&mdContext);
	MD5Update(&mdContext,data,data_len);
	MD5Final(&mdContext);
	if ( bcmp(hash1,mdContext.digest,MD5_HASH_LEN)){
		PRINT_ERR("  Error, Card value does not jive with the Software value \n");

	}

	// now hash in 64-byte chunks
	//
	rc = funcs->C_DigestInit( session, &mech );
	if (rc != CKR_OK) {
		show_error("   C_DigestInit #2", rc );
		return rc;
	}

	for (i=0; i < sizeof(data); i += 64) {
		CK_ULONG size = sizeof(data) - i;
		size = MIN(size, 64);

		rc = funcs->C_DigestUpdate( session, &data[i], size );
		if (rc != CKR_OK) {
			show_error("   C_DigestUpdate #1", rc );
			PRINT_ERR("   Offset:  %ld\n", i);
			return rc;
		}
	}

	hash_len = sizeof(hash2);
	rc = funcs->C_DigestFinal( session, hash2, &hash_len );
	if (rc != CKR_OK) {
		show_error("   C_DigestFinal #1", rc );
		return rc;
	}

	if (hash_len != MD5_HASH_LEN) {
		PRINT_ERR("   ERROR:  expected len2 to be %d.  Got %ld instead\n\n", MD5_HASH_LEN, hash_len );
		return -1;
	}


	rc = funcs->C_DigestInit( session, &mech );
	if (rc != CKR_OK) {
		show_error("   C_DigestInit #3", rc );
		return rc;
	}


	// finally, hash it in 47-byte chunks.
	//
	for (i=0; i < sizeof(data); i += 47) {
		CK_ULONG size = sizeof(data) - i;
		size = MIN(size, 47);

		rc = funcs->C_DigestUpdate( session, &data[i], size );
		if (rc != CKR_OK) {
			show_error("   C_DigestUpdate #2", rc );
			PRINT_ERR("   Offset:  %ld\n", i);
			return rc;
		}
	}

	hash_len = sizeof(hash3);
	rc = funcs->C_DigestFinal( session, hash3, &hash_len );
	if (rc != CKR_OK) {
		show_error("   C_DigestFinal #2", rc );
		return rc;
	}

	if (hash_len != MD5_HASH_LEN) {
		PRINT_ERR("   ERROR:  expected len3 to be %d.  Got %ld instead\n\n", MD5_HASH_LEN, hash_len );
		return -1;
	}


	// the hashes better be the same
	//
	if (memcmp(hash1, hash2, sizeof(hash1)) != 0) {
		PRINT_ERR("   ERROR:  hashes 1 and 2 don't match\n");
		return -1;
	}

	if (memcmp(hash1, hash3, sizeof(hash1)) != 0) {
		PRINT_ERR("   ERROR:  hashes 1 and 3 don't match\n");
		return -1;
	}


	rc = funcs->C_CloseAllSessions( slot_id );
	if (rc != CKR_OK) {
		show_error("   C_CloseAllSessions #1", rc );
		return rc;
	}

	printf("Looks okay...\n");
	return 0;
}


//
//
CK_RV do_Digest_SHA1_speed( void )
{
	CK_SESSION_HANDLE session;
	CK_SLOT_ID        slot_id;
	CK_MECHANISM      mech;
	CK_BYTE           data[BIG_REQUEST];
	CK_BYTE           hash1[SHA1_HASH_LEN];
	CK_ULONG          flags;
	CK_ULONG          data_len;
	CK_ULONG          hash_len;
	CK_ULONG          i;
	CK_RV             rc;


	printf("do_Digest_SHA1_speed.  Doing 819200 bytes in 8192 byte chunks...\n");

	slot_id = SLOT_ID;
	flags = CKF_SERIAL_SESSION | CKF_RW_SESSION;
	rc = funcs->C_OpenSession( slot_id, flags, NULL, NULL, &session );
	if (rc != CKR_OK) {
		show_error("   C_OpenSession #1", rc );
		return rc;
	}

	mech.mechanism      = CKM_SHA_1;
	mech.ulParameterLen = 0;
	mech.pParameter     = NULL;

	// generate some data to hash
	//
	data_len = sizeof(data);
	for (i=0; i < data_len; i++)
		data[i] = i % 255;


	for (i=0; i < 100; i++) {
		rc = funcs->C_DigestInit( session, &mech );
		if (rc != CKR_OK) {
			show_error("   C_DigestInit #1", rc );
			return rc;
		}

		hash_len = sizeof(hash1);
		rc = funcs->C_Digest( session, data,     data_len,
				hash1,   &hash_len );
		if (rc != CKR_OK) {
			show_error("   C_Digest #1", rc );
			return rc;
		}

		if (hash_len != SHA1_HASH_LEN) {
			PRINT_ERR("   ERROR:  expected len1 to be %d.  Got %ld instead\n\n", SHA1_HASH_LEN, hash_len );
			return -1;
		}
	}

	rc = funcs->C_CloseAllSessions( slot_id );
	if (rc != CKR_OK) {
		show_error("   C_CloseAllSessions #1", rc );
		return rc;
	}

	printf("Looks okay...\n");
	return 0;
}


//
//
CK_RV do_Digest_MD5_speed( void )
{
	CK_SESSION_HANDLE session;
	CK_SLOT_ID        slot_id;
	CK_MECHANISM      mech;
	CK_BYTE           data[BIG_REQUEST];
	CK_BYTE           hash1[MD5_HASH_LEN];
	CK_ULONG          flags;
	CK_ULONG          data_len;
	CK_ULONG          hash_len;
	CK_ULONG          i;
	CK_RV             rc;


	printf("do_Digest_MD5_speed.  Doing 819200 bytes in 8192 byte chunks...\n");

	slot_id = SLOT_ID;
	flags = CKF_SERIAL_SESSION | CKF_RW_SESSION;
	rc = funcs->C_OpenSession( slot_id, flags, NULL, NULL, &session );
	if (rc != CKR_OK) {
		show_error("   C_OpenSession #1", rc );
		return rc;
	}

	mech.mechanism      = CKM_MD5;
	mech.ulParameterLen = 0;
	mech.pParameter     = NULL;

	// generate some data to hash
	//
	data_len = sizeof(data);
	for (i=0; i < data_len; i++)
		data[i] = i % 255;


	for (i=0; i < 100; i++) {
		rc = funcs->C_DigestInit( session, &mech );
		if (rc != CKR_OK) {
			show_error("   C_DigestInit #1", rc );
			return rc;
		}

		hash_len = sizeof(hash1);
		rc = funcs->C_Digest( session, data,     data_len,
				hash1,   &hash_len );
		if (rc != CKR_OK) {
			show_error("   C_Digest #1", rc );
			return rc;
		}

		if (hash_len != MD5_HASH_LEN) {
			PRINT_ERR("   ERROR:  expected len1 to be %d.  Got %ld instead\n\n", MD5_HASH_LEN, hash_len );
			return -1;
		}
	}

	rc = funcs->C_CloseAllSessions( slot_id );
	if (rc != CKR_OK) {
		show_error("   C_CloseAllSessions #1", rc );
		return rc;
	}

	printf("Looks okay...\n");
	return 0;
}


#define MAX_HASH_LEN	512
CK_RV
do_SignVerify_HMAC(CK_MECHANISM *mech,
		   CK_ULONG      hash_len,
		   CK_BYTE      *key,
		   CK_ULONG      key_len,
		   CK_BYTE      *data,
		   CK_ULONG      data_len,
		   CK_BYTE      *result)
{
	CK_SESSION_HANDLE session;
	CK_SLOT_ID        slot_id;
	CK_ULONG          flags;
	CK_ULONG          hmac_size;
	CK_RV             rc;
	CK_OBJECT_HANDLE  h_key;
	CK_OBJECT_CLASS   key_class  = CKO_SECRET_KEY;
	CK_KEY_TYPE       key_type   = CKK_GENERIC_SECRET;
	CK_BBOOL          false      = FALSE;
	CK_BYTE           hash[MAX_HASH_LEN];
	CK_ATTRIBUTE      key_attribs[] =
	{
		{CKA_CLASS,       &key_class,  sizeof(key_class)    },
		{CKA_KEY_TYPE,    &key_type,   sizeof(key_type)     },
		{CKA_TOKEN,       &false,      sizeof(false)        },
		{CKA_VALUE,       key,         key_len              }
	};

	if (hash_len > MAX_HASH_LEN) {
		PRINT_ERR("Hash is too long, time to update testcases!!!\n");
		exit(-1);
	}

	printf("do_SignVerify(%s)...\n", p11_get_ckm(mech->mechanism));
#if 0
	PRINT_ERR("key:\n");
	print_hex(key, key_len);
	PRINT_ERR("data:\n");
	print_hex(data, data_len);
	PRINT_ERR("result:\n");
	print_hex(result, hash_len);
#endif
	slot_id = SLOT_ID;
	flags = CKF_SERIAL_SESSION | CKF_RW_SESSION;
	rc = funcs->C_OpenSession( slot_id, flags, NULL, NULL, &session );
	if (rc != CKR_OK) {
		show_error("   C_OpenSession #1", rc );
		return rc;
	}

	if (mech->pParameter)
		hmac_size = *((CK_ULONG *)mech->pParameter);
	else
		hmac_size = hash_len;
#if 0
	PRINT_ERR("hmac_size: %lu\n", hmac_size);
#endif

	rc = funcs->C_CreateObject( session, key_attribs, 4, &h_key );
	if (rc != CKR_OK) {
		show_error("   C_CreateObject", rc );
		return rc;
	}

	rc = funcs->C_SignInit( session, mech, h_key );
	if (rc != CKR_OK) {
		show_error("   C_SignInit", rc );
		return rc;
	}

	rc = funcs->C_Sign( session, data, data_len, hash, &hash_len );
	if (rc != CKR_OK) {
		show_error("   C_Sign", rc );
		return rc;
	}

	if (hash_len != hmac_size) {
		PRINT_ERR("   Error:  C_Sign generated bad HMAC length: expected %lu, got %lu\n",
			  hmac_size, hash_len);
		return -1;
	}

	if (memcmp(hash, result, hash_len) != 0) {
		PRINT_ERR("   Error:  C_Sign generated bad HMAC\n");
		PRINT_ERR("Expected:\n");
		print_hex(result, hash_len);
		PRINT_ERR("Actual:\n");
		print_hex(hash, hash_len);
		return -1;
	}

	rc = funcs->C_VerifyInit( session, mech, h_key );
	if (rc != CKR_OK) {
		show_error("   C_VerifyInit", rc );
		return rc;
	}

	rc = funcs->C_Verify( session, data, data_len, hash, hash_len );
	if (rc != CKR_OK) {
		show_error("   C_Verify", rc );
		return rc;
	}

	rc = funcs->C_DestroyObject( session, h_key );
	if (rc != CKR_OK) {
		show_error("   C_DestroyObject #1", rc );
		return rc;
	}

	rc = funcs->C_CloseAllSessions( slot_id );
	if (rc != CKR_OK) {
		show_error("   C_CloseAllSessions #1", rc );
		return rc;
	}

	printf("Success.\n");
	return 0;
}

CK_RV digest_funcs()
{
	SYSTEMTIME t1, t2;
	CK_RV rc;
	int i;

	rc = do_Digest_SHA1();
	if (rc) {
		PRINT_ERR("ERROR do_Digest_SHA1 failed, rc = 0x%lx\n", rc);
		if (!no_stop)
			return rc;
	}
	GetSystemTime(&t2);
	process_time( t1, t2 );

#if MD2
	GetSystemTime(&t1);
	rc = do_Digest_MD2();
	if (rc) {
		PRINT_ERR("ERROR do_Digest_MD2 failed, rc = 0x%lx\n", rc);
		if (!no_stop)
			return rc;
	}
	GetSystemTime(&t2);
	process_time( t1, t2 );
#endif

	GetSystemTime(&t1);
	rc = do_Digest_MD5();
	if (rc) {
		PRINT_ERR("ERROR do_Digest_MD5 failed, rc = 0x%lx\n", rc);
		if (!no_stop)
			return rc;
	}
	GetSystemTime(&t2);
	process_time( t1, t2 );

	/* HMAC tests based on the vectors defined above */
	for (i = 0; i < NUM_HMAC_TEST_VECTORS; i++) {
		GetSystemTime(&t1);
		rc = do_SignVerify_HMAC(&(hmac_test_vectors[i].mech),
					hmac_test_vectors[i].hash_len,
					hmac_test_vectors[i].key,
					hmac_test_vectors[i].key_len,
					hmac_test_vectors[i].data,
					hmac_test_vectors[i].data_len,
					hmac_test_vectors[i].result);
		GetSystemTime(&t2);
		process_time( t1, t2 );
		if (rc) {
			PRINT_ERR("ERROR do_SignVerify(%s) failed, rc = 0x%lx\n",
				  p11_get_ckm(hmac_test_vectors[i].mech.mechanism), rc);
			if (!no_stop)
				return rc;
		}
	}

	//   // these are just speed tests.  they'll take a while to complete
	//   // so don't include them in normal regression testing
	//   //
	//   GetSystemTime(&t1);
	//   rc = do_Digest_SHA1_speed();
	//   if (rc)
	//      ;
	//   GetSystemTime(&t2);
	//   process_time( t1, t2 );
	//
	//   GetSystemTime(&t1);
	//   rc = do_Digest_MD5_speed();
	//   if (rc)
	//      ;
	//   GetSystemTime(&t2);
	//   process_time( t1, t2 );

	return 0;
}


int main(int argc, char **argv)
{
	CK_C_INITIALIZE_ARGS cinit_args;
	int rc;
	CK_BBOOL no_init, no_stop;
	CK_RV rv;

	SLOT_ID = 0;
	no_init = FALSE;
	no_stop = FALSE;


	rc = do_ParseArgs(argc, argv);
	if ( rc != 1)
		return rc;

	printf("Using slot #%lu...\n\n", SLOT_ID );
	printf("With option: no_init: %d\n", no_init);

	rc = do_GetFunctionList();
	if (!rc) {
		PRINT_ERR("ERROR do_GetFunctionList() Failed , rc = 0x%0x\n", rc);
		return rc;
	}

	memset( &cinit_args, 0x0, sizeof(cinit_args) );
	cinit_args.flags = CKF_OS_LOCKING_OK;

	// SAB Add calls to ALL functions before the C_Initialize gets hit

	funcs->C_Initialize( &cinit_args );

	{
		CK_SESSION_HANDLE  hsess = 0;

		rc = funcs->C_GetFunctionStatus(hsess);
		if (rc  != CKR_FUNCTION_NOT_PARALLEL)
			return rc;

		rc = funcs->C_CancelFunction(hsess);
		if (rc  != CKR_FUNCTION_NOT_PARALLEL)
			return rc;

	}

	rv = digest_funcs();
	/* make sure we return non-zero if rv is non-zero */
	return ((rv==0) || (rv % 256) ? rv : -1);
}

