From 48c87082d3bf6a4ab23af8c451bf775b89661e36 Mon Sep 17 00:00:00 2001
From: Joy Latten <jmlatten@linux.vnet.ibm.com>
Date: Wed, 6 Nov 2013 13:39:24 -0600
Subject: [PATCH] CCA token was putting incorrect OID info into
 CKA_ECDSA_PARAMS attribute. This attribute must be passed in by the user when
 generating EC keypair and should not be over-written.

Signed-off-by: Joy Latten <jmlatten@linux.vnet.ibm.com>
---
 usr/lib/pkcs11/cca_stdll/cca_specific.c | 82 ++++++++++++++++++++-------------
 usr/lib/pkcs11/cca_stdll/mech_ec.c      | 36 +++++++--------
 2 files changed, 65 insertions(+), 53 deletions(-)

diff --git a/usr/lib/pkcs11/cca_stdll/cca_specific.c b/usr/lib/pkcs11/cca_stdll/cca_specific.c
index c8a40c1..7b98b2d 100644
--- a/usr/lib/pkcs11/cca_stdll/cca_specific.c
+++ b/usr/lib/pkcs11/cca_stdll/cca_specific.c
@@ -1395,6 +1395,7 @@ token_create_ec_keypair(TEMPLATE *publ_tmpl,
 	CK_BYTE q[CCATOK_EC_MAX_Q_LEN];
 	CK_BBOOL found = FALSE;
 	CK_RV rv;
+	CK_ATTRIBUTE *attr = NULL;
 
 	/*
 	 * The token includes the header section first,
@@ -1402,8 +1403,14 @@ token_create_ec_keypair(TEMPLATE *publ_tmpl,
 	 * and the public key section last.
 	 */
 
+	/* The pkcs#11v2.20:
+	 * CKA_ECDSA_PARAMS must be in public key's template when
+	 * generating key pair and added to private key template.
+	 * CKA_EC_POINT added to public key when key is generated.
+	 */
+
 	/*
-	 * Get Q data for public and private key.
+	 * Get Q data for public key.
 	 */
 	pubkey_offset = cca_ec_publkey_offset(tok);
 
@@ -1425,41 +1432,14 @@ token_create_ec_keypair(TEMPLATE *publ_tmpl,
 		return rv;
 	}
 
-	if ((rv = build_update_attribute(priv_tmpl, CKA_EC_POINT, q, q_len)))
-	{
-		DBG("Build and update attribute for q failed rv=0x%lx\n", rv);
-		return rv;
-	}
-
-	/*
-	 * Get ECDSA PAMRAMS for both keys.
-	 */
-	p_len_offset = pubkey_offset + CCA_PUBL_P_LEN_OFFSET;
-	p_len = *(uint16_t *)&tok[p_len_offset];
-	p_len = ntohs(p_len);
-
-	for (i = 0; i < NUMEC; i++) {
-		if (p_len == der_ec_supported[i].len_bits) {
-			found = TRUE;
-			break;
-		}
-	}
-
-	if(found == FALSE) {
-		DBG("The p len %lx is not valid.\n", p_len);
-		return CKR_FUNCTION_FAILED;
-	}
-
-	if ((rv = build_update_attribute(publ_tmpl, CKA_ECDSA_PARAMS,
-					der_ec_supported[i].data,
-					der_ec_supported[i].data_size))) {
-		DBG("Build and update attribute for der data failed rv=0x%lx\n", rv);
-		return rv;
+	/* Add ec params to private key */
+	if (!template_attribute_find(publ_tmpl, CKA_ECDSA_PARAMS, &attr)) {
+		OCK_LOG_ERR(ERR_TEMPLATE_INCOMPLETE);
+		return CKR_TEMPLATE_INCOMPLETE;
 	}
 
 	if ((rv = build_update_attribute(priv_tmpl, CKA_ECDSA_PARAMS,
-					der_ec_supported[i].data,
-					der_ec_supported[i].data_size))) {
+					attr->pValue, attr->ulValueLen))) {
 		DBG("Build and update attribute for der data failed rv=0x%lx\n", rv);
 		return rv;
 	}
@@ -2233,3 +2213,39 @@ token_specific_object_add(OBJECT *object)
 
 	return CKR_OK;
 }
+
+CK_RV
+get_ecsiglen(OBJECT *key_obj, CK_ULONG *size)
+{
+        CK_BBOOL flag;
+        CK_ATTRIBUTE *attr = NULL;
+        int i;
+
+        flag = template_attribute_find( key_obj->template,
+                        CKA_ECDSA_PARAMS, &attr );
+        if (flag == FALSE) {
+                OCK_LOG_ERR(ERR_FUNCTION_FAILED);
+                return CKR_FUNCTION_FAILED;
+        }
+
+        /* loop thru supported curves to find the size.
+         * both pkcs#11v2.20 and CCA expect the signature length to be
+         * twice the length of p.
+         * (See EC Signatures in pkcs#11v2.20 and docs for CSNDDSG.)
+         */
+        for (i = 0; i < NUMEC; i++) {
+                if ((memcmp(attr->pValue, der_ec_supported[i].data,
+                                attr->ulValueLen) == 0)) {
+			*size = der_ec_supported[i].len_bits;
+			/* round up if necessary */
+			if ((*size % 8) == 0)
+				*size = (*size / 8) * 2;
+			else
+				*size = ((*size / 8) + 1) * 2;
+                        return CKR_OK;
+                }
+        }
+
+        OCK_LOG_ERR(ERR_MECHANISM_PARAM_INVALID);
+        return CKR_MECHANISM_PARAM_INVALID;
+}
diff --git a/usr/lib/pkcs11/cca_stdll/mech_ec.c b/usr/lib/pkcs11/cca_stdll/mech_ec.c
index cf1c140..aab11b8 100644
--- a/usr/lib/pkcs11/cca_stdll/mech_ec.c
+++ b/usr/lib/pkcs11/cca_stdll/mech_ec.c
@@ -75,8 +75,7 @@ ec_sign( SESSION			*sess,
                CK_ULONG			*out_data_len )
 {
 	OBJECT          *key_obj   = NULL;
-	CK_ATTRIBUTE    *attr      = NULL;
-	CK_ULONG         public_key_len;
+	CK_ULONG         plen;
 	CK_BBOOL         flag;
 	CK_RV            rc;
 
@@ -91,23 +90,21 @@ ec_sign( SESSION			*sess,
 		return rc;
 	}
 
-	flag = template_attribute_find( key_obj->template,
-			CKA_EC_POINT, &attr );
-	if (flag == FALSE)
-		return CKR_FUNCTION_FAILED;
-	else
-		public_key_len = attr->ulValueLen;
+	rc = get_ecsiglen(key_obj, &plen);
+	if (rc != CKR_OK) {
+		OCK_LOG_ERR(ERR_FUNCTION_FAILED);
+		return rc;
+	}
 
 	if (length_only == TRUE) {
-		*out_data_len = public_key_len;
+		*out_data_len = plen;
 		return CKR_OK;
 	}
 
-	if (*out_data_len < public_key_len) {
+	if (*out_data_len < plen) {
 		OCK_LOG_ERR(ERR_BUFFER_TOO_SMALL);
 		return CKR_BUFFER_TOO_SMALL;
 	}
-	*out_data_len = public_key_len;
 
 	rc = ckm_ec_sign( in_data, in_data_len, out_data,
 			out_data_len, key_obj );
@@ -160,8 +157,7 @@ ec_verify(SESSION		*sess,
 	CK_ULONG		sig_len )
 {
 	OBJECT          *key_obj  = NULL;
-	CK_ATTRIBUTE    *attr     = NULL;
-	CK_ULONG         public_key_len;
+	CK_ULONG         plen;
 	CK_BBOOL         flag;
 	CK_RV            rc;
 
@@ -171,16 +167,16 @@ ec_verify(SESSION		*sess,
 		OCK_LOG_ERR(ERR_OBJMGR_FIND_MAP);
 		return rc;
 	}
-	flag = template_attribute_find( key_obj->template,
-			CKA_EC_POINT, &attr );
-	if (flag == FALSE)
-		return CKR_FUNCTION_FAILED;
-	else
-		public_key_len = attr->ulValueLen;
+
+	rc = get_ecsiglen(key_obj, &plen);
+	if (rc != CKR_OK) {
+		OCK_LOG_ERR(ERR_FUNCTION_FAILED);
+		return rc;
+	}
 
 	// check input data length restrictions
 	//
-	if (sig_len > public_key_len){
+	if (sig_len > plen){
 		OCK_LOG_ERR(ERR_SIGNATURE_LEN_RANGE);
 		return CKR_SIGNATURE_LEN_RANGE;
 	}
-- 
1.8.3.1

